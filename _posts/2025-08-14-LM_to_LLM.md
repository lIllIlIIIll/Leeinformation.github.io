---
layout: single
title:  "[AI 부트캠프] LM to LLM - Large Language Model 기초"
categories: Bootcamp
tag: [python, AI, 패스트캠퍼스, 패스트캠퍼스AI부트캠프, 업스테이지패스트캠퍼스, UpstageAILab, 국비지원, 패스트캠퍼스업스테이지에이아이랩, 패스트캠퍼스업스테이지부트캠프]
toc: true
author_profile: false
---

<head>
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>


◆ Pytorch - DNN 구현



> (25.06.18 위키라이더)



LM to LMM 강의의 **Large Language Model 기초** 정리



***


# What is Large Language Model?


Large Language Model(LLM) : 방대한 파라미터 수를 가진 언어모델



- 전통적인 머신러닝 모델 VS LLM



    - 전통적인 언어모델은 각각의 태스크 처리를 위해 각각의 ML 모델이 필요

    - LLM은 수많은 데이터로 훈련시키기에 여러 태스크를 하나의 LLM에서 처리 가능



- LLM의 핵심



    - ***Human Alignment*** : 인간의 선호도를 기반으로 튜닝

        - 첫 Pre-training을 통해 언어를 학습 후 두 번째 fine-tuning(Instruction Tuning)에서 인간의 선호도를 학습

    

    - 리셋 모먼트 : 인간의 업무 생산성을 높여주는 수많은 도구들이 등장 → **AI Agent**



    - ***In-Context Learning*** : 내재화된 In-Context 파라미터 정보를 이용하여 실제 모델의 능력을 끌어냄

        - **Zero-shot** : 예시를 주지 않고 명령만 줌

        - **One-shot** : 하나의 예시를 같이 줌

        - **Few-show** : 여러개의 예시를 같이 줌





> 특정 크기를 기점으로 모델의 성능이 급격히 상승 → 없던 능력이 생김(번역만 할줄 알던 모델이 요약, 정리 등의 다양한 태스크) : ***창발성***



***


## LLM의 제작 프로세스


**필요한 리소스들**



    - Infra

        - Hyper Scale Cloud

        - Super Computing

        - Hyper Scale Data Center

        - 운영 환경 (하드웨어)



    - Backbone Model

        - EX) ChatGPT : GPT 3.5 기반으로 학습



    - Tuning (비용 효율적 측면)

        - 경량화 방법

        - 반도체 기술

    

    - Data



***


- **Data Processing**



    1. Raw Corpus 수집(최소 1조개 이상)

    2. Quality Filtering : 품질이 낮은 데이터 필터링

    3. De-duplication : 중복 데이터 제거

    4. Privacy Reduction : 개인 정보와 관련된 데이터 제거

    5. Tokenization



- **Pre-training & Supervised Fine-tuning**



    - Pre-training 과정에서 문장을 생성 (다음 단어를 예측하면서)

    - Supervised Finetuning을 통해 질문에 잘 답변할 수 있도록 학습



***


## LLM의 방향성


- ***Data & Size***

    - Chinchilla : GPT에 비해 모델의 크기는 작아지고, 데이터는 많아짐

        > 모델의 전체 용량에 비해 일부만 사용하던 것을 데이터를 늘려 전체 용량 사용



    - Modeling VS Data

        - 실제 모델의 크기를 키웠을 때 Vanilla Transformer(Baseline Model)의 성능이 가장 좋았음

            > 모델의 크기를 키우고 데이터의 양을 늘리는 것이 중요

    

    - 데이터 구성

        - 말뭉치의 출처에 대한 조합에 따라 사전학습의 성능이 달라짐

        - 데이터 구성 / 데이터 비율 또한 중요함



    > 결국 사전학습 모델의 크기가 언어 모델의 능력이 창발됨



***


- ***Multimodal***

    - 언어에만 한정하는게 아닌 다양한 작업을 할 수 있는 모델 (Vision, Speech, ... etc)



- ***Multilingual***

    - 다국어 처리를 위한 모델

    - 대부분의 모델들은 현재 영어를 기반으로 처리 → 다양한 언어 처리 목적



- ***Synthetic Data***

    - 사람보다 뛰어나게 labeling하는 case가 발생

    - 모델의 성능이 올라갈수록 사람이 labeling하는 것보다 우수한 성능을 보여줌



- ***Domain Specialized***

    - 각 태스크에 맞게 잘 처리하는 것도 중요 (도메인 특화)



***


- ***Evaluation***

    - 기존 ML 평가방식과 다른 평가방식이 필요

    - Reasoning, Knowledge, Conversation, Creativity, ... 등 새로운 평가방식 사용

    - 뿐만 아니라 기존의 자연어 처리 태스크에서 부족한 수학문제와 같은 추론, 상식, 바이어스 문제 등을 얼마나 잘 해결하는지의 평가 방식도 존재

    - LLM-Eval : LLM이 LLM을 평가



***


- ***Prompt Engineering***

    - 대화형 AI가 생성하는 결과물의 품질을 높일 수 있는 prompt 입력 값들의 조합을 탐색하는 작업

    - Instruction, Context, Input Data, Output Indicator 등의 예시를 주는 방식 등



    - Chain-of-thought prompting : 답변에 도달하는 과정을 학습시키는 목적 / 사람의 생각의 흐름을 학습

    - Optimization, Tuning : Lasting step by step, 감정 호소 등 고품질의 결과물을 도출할 수 있도록 유도



    - Prompt Parameter Tuning

        - Temperature : 답변의 창의성과 무작위성 조정 / 값이 낮을수록 사실에 근거한 정확한 답변, 높을수록 창의적인 결과물

        - Top_p : 답변의 무작위성 제어

        - frequency_penalty : 값이 높을수록 흔하지 않은 단어를 답변에 포함할 가능성이 낮음

        - presence_penalty : 값이 높을수록 유사하거나 동일한 단어 및 문구를 답변 시 반복할 가능성이 낮음

    

    - Automatic Curriculum : 목표만 설정하면 달성을 위해 필요한 것들을 자동으로 실행



***


# LLM의 근간 이론


- ***In-Context Learning***

    - Fine Tuning은 대규모 corpus로 사전학습 후 적은 규모의 특화 데이터로 일부 task에 대해 능력을 집중적으로 향상시키는 작업

        > 모델의 가중치를 업데이트하면서 gradient가 업데이트 됨

    

    - In-Context Learning은 Zero-shot, One-shot, Few-shot을 통해 프롬프트를 주는 것 만으로도 성능 향상 가능

        > 모델의 가중치를 업데이트 하지 않음



    - **Zero-Shot Learning** : 예시를 전혀 보지 않고 모델 업데이트 없이 새로운 태스크 수행

        > 특정 작업(독해, 번역, 요약, Q&A 등)에서 기존의 SOTA 모델들보다 좋음



    - **One-Shot Learning** : 단 하나의 예시와 task에 대한 자연어 지시문을 제공

        > 사람이 소통하는 방법과 가장 흡사

    

    - **Few-Shot Learning** : 모델 추론 시 단 몇 개의 예시만 참고하여 정답 생성

        > 새로운 태스크에 효율적으로 빠르게 적응



***


## ChatGPT


- ***ChatGPT***

    - Multi-Tasking : 기존의 chatbot은 여러 개의 언어 모델이 조합됨 / ChatGPT는 하나의 모델이지만 다양한 태스크를 수행할 수 있음



    - 외부 Plugin과 결합하려는 시도



    - GPT-3.5를 fine-tuning

    - InstructGPT의 'sibling model', 학습 방식 유사

    - Demonstration Data : 데이터를 대화형으로 바꿈

    - 보상 모델을 활용하여 강화학습으로 업데이트



- ***ChatGPT 학습 방법***



    - 일반적인 언어모델은 다음 토큰 예측 or 일부 태크스를 수행하는 것에 초점

        > 사람의 지시에 따르지 못함

    - Instruction Tuning을 통해 사람의 명령을 따르도록 Fine Tuning



    1. SFT(Supervised Fine Tuning)

        - 예제 데이터 수집 후 Supervised policy 학습

        - 이를 위해 지시 프롬프트와 그에 대한 결과물로 이루어진 데이터셋 정의

        - 해당 데이터셋을 GPT-3에 대해 Fine-Tuning → SFT 모델



    2. 결과물에 대한 사람의 선호도 데이터 학습

        - Reward Model 학습 : SFT로 생성된 결과물에 대해 사람의 선호도를 반영할 수 있는 Reward Model 학습

        - Comparison dataset은 33K 개의 프롬프트(프롬프트와 그에 따른 결과물, 그 결과에 대한 선호도 순위로 구성)로 이를 Reward Model 학습에 적합하게 구성

        - 프롬프트가 주어질 때 Reward Model은 결과물에 대해 사람의 선호도를 예측하는 방법 학습



    3. RLHF

        - 강화학습을 통해 Reward Model에 대해 policy를 최적화



            1. GPT는 프롬프트를 보고 결과 문장 생성

            2. 생성된 문장들을 Reward Model이 평가, reward 계산

            3. 보상 값이 GPT에게 주어지고 모델은 보상을 최대화하는 방향, 사람이 원하는 문장을 생성하는 방향으로 정책 업데이트



***


- ***ChatGPT 활용법***

    - Persona Injection : 사용자의 특성, GPT의 역할 등을 먼저 정의 후 태스크 수행

    - 프롬프트 구성 : 지시사항, 참고 데이터, 출력 지도, 사용자 입력데이터

    - 출력물 형태 지정

    - 문장이 길어지거나 복잡하다면 구역을 지정

    - 예시 들기



***


## PEFT


> 모델이 점점 커지면서 일반적인 그래픽카드로 모델 전체를 fine tuning하는 것은 불가능



- ***PEFT*** : 사전 훈련된 언어 모델을 특정 작업이나 상황에 적용할 때, 가중치의 일부만 업데이트하는 fine tuning 방법

    - 일부만 fine tuning하므로 연산량 대폭 감소

    - catastrophic forgetting 완화

    - 적은 데이터에서 fine tuning 하거나, 도메인 밖의 데이터를 일반화할 때 좋은 성능



    > 적은 수의 파라미터를 학습하는 것만으로 모델 전체를 fine tuning 하는 것과 유사한 효과



- ***Prefix-Tuning*** : 연속적인 태스크 특화 벡터를 활용해 언어모델을 최적화

    - 각 layer의 입력 앞에 task-specific vectors를 붙여 tuning

    - 각 task에 대하여 파라미터를 튜닝시켜 task마다 적합한 task-specific vectors 도출



    > 하나의 언어모델로 여러 개의 태스크를 처리할 수 있음



- ***Prompt Tuning*** : 전체 파라미터 튜닝하는 대신, 입력 프롬프트 임베딩만 학습

    - PSMs를 동결시키고 입력 텍스트에 추가되는 downstream task 당 k개의 토큰만 학습



    > 모델에 입력되는 프롬프트에 해당하는 가중치만 학습



- ***P-Tuning*** : PLMs의 전체 가중치를 fine-tuning하지 않고, continuous prompt embeddings만 tuning

    - 언어모델의 입력부에 prompt encoder를 두어 나온 출력 값을 prompt의 tokne embedding으로 사용

    - 태스크와 관련된 anchor tokens을 추가하여 성능 개선



- ***LoRA*** : 사전 학습된 가중치를 고정한 상태로 유지하며, dense layer 변화에 대한 rank decomposition metrices를 최적화

    - 기존 출력층에 저차원의 피드포워드 layer를 추가, adapter layer만 학습



- ***Quantization*** : 추론 시간을 줄이는 것이 주 목적

    - 모델의 파라미터를 lower bit로 표현함으로써 계산과 메모리 접근 속도를 높이는 경량화 기법



- ***QLoRA*** : 기존 사전학습 모델의 가중치는 양자화로 저장, LoRA에 의해 더해지는 가중치는 16 bit finetuning 유지

    > 메모리 사용량을 대폭 줄임으로써 효율적으로 언어 모델 사용 가능



- ***IA3*** : Self-Attention, Cross-Attention에서의 키, 밸류 값을 rescale해주는 벡터와 position-wise feed-forward network의 값에 rescale을 해주는 벡터를 추가하여 모델 튜닝

    > 기존에 공개된 LoRA보다 적은 파라미터를 사용



***

